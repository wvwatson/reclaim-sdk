"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateProviderReceipt = void 0;
const tls_1 = require("@reclaimprotocol/tls");
const config_1 = require("../config");
const providers_1 = require("../providers");
const utils_1 = require("../utils");
const make_api_tls_client_1 = require("./make-api-tls-client");
async function generateProviderReceipt({ name, secretParams, params, client, requestData, additionalConnectOpts, logger, zkOperator, zkProofConcurrency }) {
    var _a;
    logger = logger || utils_1.logger;
    const provider = providers_1.providers[name];
    const hostPort = typeof provider.hostPort === 'function'
        // @ts-ignore
        ? provider.hostPort(params)
        : provider.hostPort;
    const [host, port] = hostPort.split(':');
    additionalConnectOpts = additionalConnectOpts || {};
    if ((_a = provider.additionalClientOptions) === null || _a === void 0 ? void 0 : _a.rootCAs) {
        additionalConnectOpts.rootCAs = [
            ...(additionalConnectOpts.rootCAs || []),
            ...provider.additionalClientOptions.rootCAs,
        ];
    }
    const resParser = (0, utils_1.makeHttpResponseParser)();
    const apiClient = (0, make_api_tls_client_1.makeAPITLSClient)({
        host,
        port: port ? +port : config_1.DEFAULT_PORT,
        request: requestData,
        client,
        logger,
        additionalConnectOpts,
        zkOperator,
        zkProofConcurrency,
        handleDataFromServer(data) {
            resParser.onChunk(data);
            if (resParser.res.complete) {
                // wait 1 tick to make sure the client has
                // finished writing the response
                setTimeout(() => {
                    endedHttpRequest === null || endedHttpRequest === void 0 ? void 0 : endedHttpRequest();
                }, 100);
            }
        },
        onTlsEnd(err) {
            const level = err ? 'error' : 'debug';
            logger === null || logger === void 0 ? void 0 : logger[level]({ err }, 'tls session ended');
            endedHttpRequest === null || endedHttpRequest === void 0 ? void 0 : endedHttpRequest(err);
            try {
                resParser.streamEnded();
            }
            catch (_a) { }
        },
        redactResponse: provider.getResponseRedactions
            ? res => {
                // @ts-ignore
                return provider.getResponseRedactions(res, params);
            }
            : undefined
    });
    let endedHttpRequest;
    const request = provider.createRequest(
    // @ts-ignore
    secretParams, params);
    logger.debug({ redactions: request.redactions.length }, 'generated request');
    const waitForRequestEnd = new Promise((resolve, reject) => {
        endedHttpRequest = err => (err ? reject(err) : resolve());
    });
    await apiClient.connect();
    const reqData = typeof request.data === 'string'
        ? (0, tls_1.strToUint8Array)(request.data)
        : request.data;
    await apiClient.write(reqData, request.redactions);
    logger.info('wrote request to server');
    await waitForRequestEnd;
    const res = await apiClient.finish();
    logger.info({ claimData: res.claimData }, 'finished request');
    return res;
}
exports.generateProviderReceipt = generateProviderReceipt;
