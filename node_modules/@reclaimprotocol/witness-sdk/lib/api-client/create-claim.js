"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createClaim = void 0;
const ethers_1 = require("ethers");
const beacon_1 = require("../beacon");
const providers_1 = require("../providers");
const utils_1 = require("../utils");
const generate_provider_receipt_1 = require("./generate-provider-receipt");
/**
 * Create a claim on chain
 * @param param0 parameters to create the claim with
 */
async function createClaim({ name, params, secretParams, resumeFromStep, additionalConnectOpts, zkOperator, ownerPrivateKey, didUpdateCreateStep, context = '', beacon = (0, beacon_1.makeBeacon)(), logger = utils_1.logger, makeGrpcClient = utils_1.createGrpcWebClient, zkProofConcurrency }) {
    if (!providers_1.providers[name].areValidParams(params)) {
        throw new Error(`Invalid params for provider "${name}"`);
    }
    additionalConnectOpts = {
        ...providers_1.providers[name].additionalClientOptions || {},
        ...additionalConnectOpts,
    };
    let witnessHosts;
    let timestampS;
    let epoch;
    let claimData;
    const claimInfo = {
        provider: name,
        parameters: (0, utils_1.stringifyClaimParameters)(params),
        context,
    };
    const identifier = (0, utils_1.getIdentifierFromClaimInfo)(claimInfo);
    const signatures = [];
    if (!resumeFromStep) {
        const state = await beacon.getState();
        timestampS = (0, utils_1.unixTimestampSeconds)();
        witnessHosts = (0, utils_1.fetchWitnessListForClaim)(state, identifier, timestampS)
            .map(w => w.url);
        epoch = state.epoch;
        didUpdateCreateStep === null || didUpdateCreateStep === void 0 ? void 0 : didUpdateCreateStep({
            name: 'creating',
            timestampS,
            epoch,
            witnessHosts,
        });
    }
    else {
        epoch = resumeFromStep.epoch;
        timestampS = resumeFromStep.timestampS;
        if (resumeFromStep.name === 'witness-done') {
            witnessHosts = resumeFromStep.witnessHostsLeft;
            claimData = resumeFromStep.claimData;
            signatures.push(...resumeFromStep.signaturesDone);
        }
        else {
            witnessHosts = resumeFromStep.witnessHosts;
        }
    }
    logger = logger.child({ identifier });
    logger.info({ witnessHosts, timestampS, epoch }, 'got witness list, sending requests to witnesses');
    if (!(witnessHosts === null || witnessHosts === void 0 ? void 0 : witnessHosts.length)) {
        throw new Error('No witness hosts were provided');
    }
    const providerClaimReq = {
        epoch,
        timestampS,
        info: claimInfo,
        ownerProof: undefined,
    };
    providerClaimReq.ownerProof = await (0, utils_1.makeOwnerProof)(providerClaimReq, ownerPrivateKey);
    for (let i = 0; i < witnessHosts.length; i++) {
        const witnessHost = witnessHosts[i];
        logger.trace({ witnessHost }, 'generating signature for oracle host');
        const grpcUrl = witnessHost.startsWith('http:') || witnessHost.startsWith('https:')
            ? witnessHost
            : `https://${witnessHost}`;
        const { signature, claimData: r } = await generateSignature(grpcUrl);
        claimData = r;
        signatures.push(signature);
        logger.info({ witnessHost }, 'generated signature for oracle host');
        didUpdateCreateStep === null || didUpdateCreateStep === void 0 ? void 0 : didUpdateCreateStep({
            name: 'witness-done',
            timestampS,
            epoch,
            signaturesDone: signatures,
            claimData,
            witnessHostsLeft: witnessHosts.slice(i + 1),
        });
    }
    return {
        identifier,
        claimData: claimData,
        signatures,
        witnessHosts,
    };
    async function generateSignature(grpcWebUrl) {
        // the trailing slash messes up the grpc-web client
        if (grpcWebUrl.endsWith('/')) {
            grpcWebUrl = grpcWebUrl.slice(0, -1);
        }
        const grpcClient = makeGrpcClient(grpcWebUrl, logger);
        const { claimData, signature, } = await (0, generate_provider_receipt_1.generateProviderReceipt)({
            name,
            secretParams,
            params,
            requestData: {
                beaconBasedProviderClaimRequest: providerClaimReq,
                receiptGenerationRequest: undefined,
            },
            client: grpcClient,
            additionalConnectOpts,
            logger,
            zkOperator,
            zkProofConcurrency,
        });
        return {
            signature: ethers_1.ethers.utils.hexlify(signature).toLowerCase(),
            claimData
        };
    }
}
exports.createClaim = createClaim;
