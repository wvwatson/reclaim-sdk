"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tls_1 = require("@reclaimprotocol/tls");
const config_1 = require("../../config");
const api_1 = require("../../proto/api");
const utils_1 = require("../../utils");
const utils_2 = require("./utils");
const OK_HTTP_HEADER = 'HTTP/1.1 200 OK';
const HTTP_PROVIDER = {
    hostPort(params) {
        const { host } = new URL(params.url);
        if (!host) {
            throw new Error('url is incorrect');
        }
        return host;
    },
    areValidParams(params) {
        return (typeof params.url === 'string' &&
            (params.method === 'GET' || params.method === 'POST') &&
            Array.isArray(params.responseSelections) &&
            params.responseSelections.length > 0);
    },
    createRequest(secretParams, params) {
        if (!secretParams.cookieStr && !secretParams.authorisationHeader) {
            throw new Error('auth parameters are not set');
        }
        let headers = [];
        if (params.headers) {
            headers = (0, utils_2.buildHeaders)(params.headers);
        }
        const authStr = [];
        if (secretParams.cookieStr) {
            authStr.push(`Cookie: ${secretParams.cookieStr}`);
        }
        if (secretParams.authorisationHeader) {
            authStr.push(`Authorization: ${secretParams.authorisationHeader}`);
        }
        let authLen = authStr.reduce((sum, current) => sum + current.length, 0);
        if (authStr.length > 1) {
            authLen += 2; //add \r\n
        }
        const hostPort = this.hostPort instanceof Function ? this.hostPort(params) : this.hostPort;
        const { pathname } = new URL(params.url);
        const strRequest = [
            `${params.method} ${pathname} HTTP/1.1`,
            `Host: ${hostPort}`,
            ...headers,
            ...authStr,
            'Content-Length: 0',
            'Connection: close',
            'User-Agent: ' + config_1.RECLAIM_USER_AGENT,
            //no compression
            'accept-encoding: identity',
            '\r\n',
        ].join('\r\n');
        const data = (0, tls_1.strToUint8Array)(strRequest);
        // the string index will work here as long as
        // the string is ascii
        const tokenStartIndex = strRequest.indexOf(authStr[0]);
        return {
            data,
            redactions: [
                {
                    fromIndex: tokenStartIndex,
                    toIndex: tokenStartIndex + authLen,
                },
            ],
        };
    },
    assertValidProviderReceipt(receipt, params) {
        const req = (0, utils_1.getHttpRequestHeadersFromTranscript)(receipt.transcript);
        if (req.method !== params.method.toLowerCase()) {
            throw new Error(`Invalid method: ${req.method}`);
        }
        const { hostname, pathname, port } = new URL(params.url);
        if (!hostname || !pathname) {
            throw new Error('url is incorrect');
        }
        if (req.url !== pathname) {
            throw new Error(`Invalid URL: ${req.url}`);
        }
        const expHostPort = `${hostname}:${port || config_1.DEFAULT_PORT}`;
        if (receipt.hostPort !== expHostPort) {
            throw new Error(`Expected hostPort: ${expHostPort}, found: ${receipt.hostPort}`);
        }
        const res = Buffer.concat(receipt.transcript
            .filter((r) => r.senderType ===
            api_1.TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER &&
            !r.redacted)
            .map((r) => r.message)).toString();
        if (!res.includes(OK_HTTP_HEADER)) {
            throw new Error('Invalid response');
        }
        if (req.headers['connection'] !== 'close') {
            throw new Error('Invalid connection header');
        }
        for (const rs of params.responseSelections) {
            if (!new RegExp(rs.responseMatch, 'sgi').test(res)) {
                throw new Error(`Invalid receipt. Regex ${rs.responseMatch} failed to match`);
            }
        }
    },
    getResponseRedactions(response, params) {
        var _a;
        if (!((_a = params.responseSelections) === null || _a === void 0 ? void 0 : _a.length)) {
            return [];
        }
        const res = (0, utils_2.parseHttpResponse)(response);
        const headerEndIndex = res.statusLineEndIndex;
        const bodyStartIdx = res.bodyStartIndex;
        if (bodyStartIdx < 4) {
            throw new Error('Failed to find body');
        }
        const body = (0, utils_1.uint8ArrayToBinaryStr)(res.body);
        const reveals = [{ fromIndex: 0, toIndex: headerEndIndex }];
        for (const rs of params.responseSelections) {
            let element = body;
            let elementIdx = -1;
            let elementLength = -1;
            if (rs.xPath) {
                element = (0, utils_2.extractHTMLElement)(body, rs.xPath, !!rs.jsonPath);
                elementIdx = body.indexOf(element);
                if (elementIdx < 0) {
                    throw new Error(`Failed to find element: "${rs.xPath}"`);
                }
                elementLength = element.length;
            }
            if (rs.jsonPath) {
                const { start, end } = (0, utils_2.extractJSONValueIndex)(element, rs.jsonPath);
                // if there's only json path used
                if (elementIdx < 0) {
                    elementIdx = 0;
                }
                if (start < 0) {
                    throw new Error('Failed to find element');
                }
                element = body.slice(elementIdx + start, elementIdx + end);
                elementIdx += start;
                elementLength = end - start;
            }
            const regexp = new RegExp(rs.responseMatch, 'gim');
            if (!regexp.test(element)) {
                throw new Error('regexp does not match found element');
            }
            if (elementIdx > 0 && elementLength > 0) {
                const from = (0, utils_2.convertResponsePosToAbsolutePos)(elementIdx, bodyStartIdx, res.chunks);
                const to = (0, utils_2.convertResponsePosToAbsolutePos)(elementIdx + elementLength, bodyStartIdx, res.chunks);
                reveals.push({ fromIndex: from, toIndex: to });
            }
        }
        reveals.sort((a, b) => {
            return a.toIndex - b.toIndex;
        });
        const redactions = [];
        if (reveals.length > 1) {
            let currentIndex = 0;
            for (const r of reveals) {
                if (currentIndex < r.fromIndex) {
                    redactions.push({ fromIndex: currentIndex, toIndex: r.fromIndex });
                }
                currentIndex = r.toIndex;
            }
            redactions.push({ fromIndex: currentIndex, toIndex: response.length });
        }
        return redactions;
    },
};
exports.default = HTTP_PROVIDER;
