"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseHttpResponse = exports.convertResponsePosToAbsolutePos = exports.buildHeaders = exports.extractJSONValueIndex = exports.extractHTMLElement = void 0;
const esprima_next_1 = require("esprima-next");
const jsdom = __importStar(require("jsdom"));
const jsonpath_plus_1 = require("jsonpath-plus");
const utils_1 = require("../../utils");
// utilise JSDom on NodeJS, otherwise
// use the browser's window object
const Window = typeof window !== 'undefined'
    ? window
    : new jsdom.JSDOM().window;
function extractHTMLElement(html, xpathExpression, contentsOnly) {
    var _a;
    const domParser = new Window.DOMParser();
    const dom = domParser.parseFromString(html, 'text/html');
    const node = (_a = dom
        .evaluate(xpathExpression, dom, null, Window.XPathResult.FIRST_ORDERED_NODE_TYPE, null)) === null || _a === void 0 ? void 0 : _a.singleNodeValue;
    if (!node) {
        return 'Element not found';
    }
    if (contentsOnly) {
        return node.textContent;
    }
    const xmlSerializer = new Window.XMLSerializer();
    return xmlSerializer
        .serializeToString(node)
        .replace(/ xmlns="[^"]+"/, '');
}
exports.extractHTMLElement = extractHTMLElement;
function extractJSONValueIndex(json, jsonPath) {
    const pointers = (0, jsonpath_plus_1.JSONPath)({
        path: jsonPath,
        json: JSON.parse(json),
        wrap: false,
        resultType: 'pointer',
    });
    if (!pointers) {
        throw new Error('jsonPath not found');
    }
    const tree = (0, esprima_next_1.parseScript)('(' + json + ')', { range: true }); //wrap in parentheses for esprima to parse
    if (tree.body[0] instanceof esprima_next_1.ExpressionStatement) {
        if (tree.body[0].expression instanceof esprima_next_1.ObjectExpression) {
            const index = traverse(tree.body[0].expression, '', pointers);
            if (index) {
                return {
                    start: index.start - 1,
                    end: index.end - 1,
                };
            }
        }
    }
    throw new Error('jsonPath not found');
}
exports.extractJSONValueIndex = extractJSONValueIndex;
/**
 * recursively go through AST tree and build a JSON path while it's not equal to the one we search for
 * @param o - esprima expression for root object
 * @param path - path that is being built
 * @param pointer - JSON pointer to compare to
 */
function traverse(o, path, pointer) {
    if (o instanceof esprima_next_1.ObjectExpression) {
        for (const p of o.properties) {
            if (p instanceof esprima_next_1.Property) {
                let localPath;
                if (p.key.type === esprima_next_1.Syntax.Literal) {
                    localPath = path + '/' + p.key.value;
                }
                else {
                    localPath = path;
                }
                if (localPath === pointer && 'range' in p && Array.isArray(p.range)) {
                    return {
                        start: p.range[0],
                        end: p.range[1],
                    };
                }
                if (p.value instanceof esprima_next_1.ObjectExpression) {
                    const res = traverse(p.value, localPath, pointer);
                    if (res) {
                        return res;
                    }
                }
                if (p.value instanceof esprima_next_1.ArrayExpression) {
                    const res = traverse(p.value, localPath, pointer);
                    if (res) {
                        return res;
                    }
                }
            }
        }
    }
    if (o instanceof esprima_next_1.ArrayExpression) {
        for (let i = 0; i < o.elements.length; i++) {
            const element = o.elements[i];
            if (!element) {
                continue;
            }
            const localPath = path + '/' + i;
            if (localPath === pointer &&
                'range' in element &&
                Array.isArray(element.range)) {
                return {
                    start: element.range[0],
                    end: element.range[1],
                };
            }
            if (element instanceof esprima_next_1.ObjectExpression) {
                const res = traverse(element, localPath, pointer);
                if (res) {
                    return res;
                }
            }
            if (element instanceof esprima_next_1.ArrayExpression) {
                const res = traverse(element, localPath, pointer);
                if (res) {
                    return res;
                }
            }
        }
    }
    return null;
}
function buildHeaders(input) {
    const headers = [];
    for (const [key, value] of Object.entries(input)) {
        headers.push(`${key}: ${value}`);
    }
    return headers;
}
exports.buildHeaders = buildHeaders;
/**
 * Converts position in HTTP response body to an absolute position in TLS transcript considering chunked encoding
 * @param pos
 * @param bodyStartIdx
 * @param chunks
 */
function convertResponsePosToAbsolutePos(pos, bodyStartIdx, chunks) {
    if (chunks === null || chunks === void 0 ? void 0 : chunks.length) {
        let chunkBodyStart = 0;
        for (let i = 0; i < chunks.length; i++) {
            const chunkSize = chunks[i].toIndex - chunks[i].fromIndex;
            if (pos >= chunkBodyStart && pos < (chunkBodyStart + chunkSize)) {
                return pos - chunkBodyStart + chunks[i].fromIndex;
            }
            chunkBodyStart += chunkSize;
        }
        throw new Error('position out of range');
    }
    return bodyStartIdx + pos;
}
exports.convertResponsePosToAbsolutePos = convertResponsePosToAbsolutePos;
function parseHttpResponse(buff) {
    const parser = (0, utils_1.makeHttpResponseParser)();
    parser.onChunk(buff);
    parser.streamEnded();
    return parser.res;
}
exports.parseHttpResponse = parseHttpResponse;
