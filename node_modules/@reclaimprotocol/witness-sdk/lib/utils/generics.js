"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gunzipSync = exports.uint8ArrayToBinaryStr = exports.findIndexInUint8Array = exports.makeGrpcWebTransport = exports.createGrpcWebClient = exports.unixTimestampSeconds = exports.getTranscriptString = exports.uint8ArrayToStr = void 0;
const common_grpc_web_transport_1 = require("@reclaimprotocol/common-grpc-web-transport");
const tls_1 = require("@reclaimprotocol/tls");
const nice_grpc_web_1 = require("nice-grpc-web");
const api_1 = require("../proto/api");
function uint8ArrayToStr(arr) {
    return new TextDecoder().decode(arr);
}
exports.uint8ArrayToStr = uint8ArrayToStr;
function getTranscriptString(transcript) {
    var _a;
    const strList = [];
    for (const msg of transcript) {
        const sender = msg.senderType === api_1.TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT
            ? 'client'
            : 'server';
        const content = msg.redacted
            ? '****'
            : uint8ArrayToStr(msg.message);
        if ((_a = strList[strList.length - 1]) === null || _a === void 0 ? void 0 : _a.startsWith(sender)) {
            strList[strList.length - 1] += content;
        }
        else {
            strList.push(`${sender}: ${content}`);
        }
    }
    return strList.join('\n');
}
exports.getTranscriptString = getTranscriptString;
const unixTimestampSeconds = () => Math.floor(Date.now() / 1000);
exports.unixTimestampSeconds = unixTimestampSeconds;
function createGrpcWebClient(url, logger) {
    const transportFactory = makeGrpcWebTransport(logger);
    const grpcChannel = (0, nice_grpc_web_1.createChannel)(url, transportFactory);
    return (0, nice_grpc_web_1.createClient)(api_1.ReclaimWitnessDefinition, grpcChannel, {});
}
exports.createGrpcWebClient = createGrpcWebClient;
function makeGrpcWebTransport(logger) {
    logger = logger === null || logger === void 0 ? void 0 : logger.child({ module: 'grpc-web-transport' });
    return (0, common_grpc_web_transport_1.CommonTransport)({ logger });
}
exports.makeGrpcWebTransport = makeGrpcWebTransport;
/**
 * Find index of needle in haystack
 */
function findIndexInUint8Array(haystack, needle) {
    for (let i = 0; i < haystack.length; i++) {
        if ((0, tls_1.areUint8ArraysEqual)(haystack.slice(i, i + needle.length), needle)) {
            return i;
        }
    }
    return -1;
}
exports.findIndexInUint8Array = findIndexInUint8Array;
/**
 * convert a Uint8Array to a binary encoded str
 * from: https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L1063
 * @param buf
 * @returns
 */
function uint8ArrayToBinaryStr(buf) {
    let ret = '';
    buf.forEach(v => (ret += String.fromCharCode(v)));
    return ret;
}
exports.uint8ArrayToBinaryStr = uint8ArrayToBinaryStr;
function gunzipSync(buf) {
    const { gunzipSync } = require('zlib');
    return gunzipSync(buf);
}
exports.gunzipSync = gunzipSync;
