import { ZKOperator } from '@reclaimprotocol/circom-chacha20';
import { FinaliseSessionRequest_Block as BlockReveal, FinaliseSessionRequest_BlockRevealZk } from '../proto/api';
import { ArraySlice, Logger } from '../types';
type ZKChunk = {
    chunk: Uint8Array;
    counter: number;
};
type BlockWithPlaintext = Partial<BlockReveal> & {
    ciphertext: Uint8Array;
    plaintext: Uint8Array;
};
type ZKBlock = {
    block: BlockWithPlaintext;
    redactedPlaintext: Uint8Array;
    zkChunks: ZKChunk[];
};
export type PrepareZKProofsBaseOpts = {
    /** params for ZK proof gen */
    zkOperator?: ZKOperator;
    /**
     * max number of ZK proofs to generate concurrently
     * @default 1
     */
    zkProofConcurrency?: number;
};
type PrepareZKProofsOpts = {
    /** blocks to prepare ZK proof for */
    blocks: BlockWithPlaintext[];
    /** redact selected portions of the plaintext */
    redact: (plaintext: Uint8Array) => ArraySlice[];
    logger?: Logger;
} & PrepareZKProofsBaseOpts;
type ZKVerifyOpts = {
    ciphertext: Uint8Array;
    zkReveal: FinaliseSessionRequest_BlockRevealZk;
    operator: ZKOperator;
    logger?: Logger;
};
export declare function makeDefaultZkOperator(logger?: Logger): Promise<ZKOperator>;
/**
 * Generate ZK proofs for the given blocks with a redaction function.
 */
export declare function prepareZkProofs({ blocks, zkOperator, redact, logger, zkProofConcurrency, }: PrepareZKProofsOpts): Promise<"all" | ZKBlock[]>;
/**
 * Verify the given ZK proof
 */
export declare function verifyZKBlock({ ciphertext, zkReveal, operator, logger }: ZKVerifyOpts): Promise<{
    redactedPlaintext: Uint8Array;
}>;
export {};
