"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyZKBlock = exports.prepareZkProofs = exports.makeDefaultZkOperator = void 0;
const circom_chacha20_1 = require("@reclaimprotocol/circom-chacha20");
const common_grpc_web_transport_1 = require("@reclaimprotocol/common-grpc-web-transport");
const p_queue_1 = __importDefault(require("p-queue"));
const config_1 = require("../config");
const logger_1 = require("./logger");
const redactions_1 = require("./redactions");
const CHACHA_BLOCK_SIZE = 64;
let zkOperator;
function makeDefaultZkOperator(logger) {
    if (!zkOperator) {
        const isNode = (0, common_grpc_web_transport_1.detectEnvironment)() === 'node';
        logger === null || logger === void 0 ? void 0 : logger.debug({ type: isNode ? 'local' : 'remote' }, 'using zk operator');
        zkOperator = isNode
            ? (0, circom_chacha20_1.makeLocalSnarkJsZkOperator)(logger)
            : (0, circom_chacha20_1.makeRemoteSnarkJsZkOperator)(config_1.DEFAULT_REMOTE_ZK_PARAMS, logger);
    }
    return zkOperator;
}
exports.makeDefaultZkOperator = makeDefaultZkOperator;
/**
 * Generate ZK proofs for the given blocks with a redaction function.
 */
async function prepareZkProofs({ blocks, zkOperator, redact, logger, zkProofConcurrency = 10, }) {
    const blocksToReveal = (0, redactions_1.getBlocksToReveal)(blocks, redact);
    if (blocksToReveal === 'all') {
        return 'all';
    }
    const zkQueue = new p_queue_1.default({
        concurrency: zkProofConcurrency,
        autoStart: true,
    });
    logger = logger || logger_1.logger.child({ module: 'zk' });
    zkOperator = zkOperator || await makeDefaultZkOperator(logger);
    logger.info({ len: blocksToReveal.length, zkProofConcurrency }, 'preparing proofs for blocks');
    let totalChunks = 0;
    const zkBlocks = blocksToReveal.map((block) => {
        const chunks = getBlockWithIvCounter(block.redactedPlaintext);
        totalChunks += chunks.length;
        return {
            block: block.block,
            zkChunks: chunks,
            redactedPlaintext: block.redactedPlaintext
        };
    });
    if (totalChunks > config_1.MAX_ZK_CHUNKS) {
        throw new Error(`Too many chunks to prove: ${totalChunks} > ${config_1.MAX_ZK_CHUNKS}`);
    }
    logger.info({ totalChunks }, 'extracted chunks');
    await Promise.all(zkBlocks.map(async (block) => {
        const { block: b, zkChunks } = block;
        b.zkReveal = {
            proofs: await Promise.all(zkChunks.map(chunk => {
                return zkQueue.add(() => generateProofForChunk(block, chunk), { throwOnTimeout: true });
            }))
        };
        delete b.directReveal;
        return block;
    }));
    return zkBlocks;
    async function generateProofForChunk({ block, redactedPlaintext }, { chunk, counter }) {
        const startIdx = (counter - 1) * CHACHA_BLOCK_SIZE;
        const endIdx = counter * CHACHA_BLOCK_SIZE;
        const ciphertextChunk = block.ciphertext.slice(startIdx, endIdx);
        const redactedPlaintextChunk = redactedPlaintext.slice(startIdx, endIdx);
        // redact ciphertext if plaintext is redacted
        // to prepare for decryption in ZK circuit
        // the ZK circuit will take in the redacted ciphertext,
        // which shall produce the redacted plaintext
        for (let i = 0; i < ciphertextChunk.length; i++) {
            if (redactedPlaintextChunk[i] === redactions_1.REDACTION_CHAR_CODE) {
                ciphertextChunk[i] = redactions_1.REDACTION_CHAR_CODE;
            }
        }
        const proof = await (0, circom_chacha20_1.generateProof)({
            key: block.directReveal.key,
            iv: block.directReveal.iv,
            startCounter: counter,
        }, {
            ciphertext: ciphertextChunk
        }, zkOperator);
        logger === null || logger === void 0 ? void 0 : logger.debug({ startIdx, endIdx }, 'generated proof for chunk');
        return {
            proofJson: proof.proofJson,
            decryptedRedactedCiphertext: (0, circom_chacha20_1.toUint8Array)(proof.plaintext),
            redactedPlaintext: chunk,
            startIdx,
        };
    }
}
exports.prepareZkProofs = prepareZkProofs;
/**
 * Verify the given ZK proof
 */
async function verifyZKBlock({ ciphertext, zkReveal, operator, logger }) {
    if (!zkReveal) {
        throw new Error('No ZK reveal');
    }
    const { proofs } = zkReveal;
    /**
     * to verify if the user has given us the correct redacted plaintext,
     * and isn't providing plaintext that they haven't proven they have
     * we start with a fully redacted plaintext, and then replace the
     * redacted parts with the plaintext that the user has provided
     * in the proofs
     */
    const realRedactedPlaintext = new Uint8Array(ciphertext.length).fill(redactions_1.REDACTION_CHAR_CODE);
    await Promise.all(proofs.map(async ({ proofJson, decryptedRedactedCiphertext, redactedPlaintext, startIdx, }, i) => {
        // get the ciphertext chunk we received from the server
        // the ZK library, will verify that the decrypted redacted
        // ciphertext matches the ciphertext received from the server
        const ciphertextChunk = ciphertext.slice(startIdx, startIdx + redactedPlaintext.length);
        // redact ciphertext if plaintext is redacted
        // to prepare for decryption in ZK circuit
        // the ZK circuit will take in the redacted ciphertext,
        // which shall produce the redacted plaintext
        for (let i = 0; i < ciphertextChunk.length; i++) {
            if (redactedPlaintext[i] === redactions_1.REDACTION_CHAR_CODE) {
                ciphertextChunk[i] = redactions_1.REDACTION_CHAR_CODE;
            }
        }
        if (!(0, redactions_1.isRedactionCongruent)(redactedPlaintext, decryptedRedactedCiphertext)) {
            throw new Error(`redacted ciphertext (${i}) not congruent`);
        }
        await (0, circom_chacha20_1.verifyProof)({
            proofJson,
            plaintext: (0, circom_chacha20_1.toUintArray)(decryptedRedactedCiphertext),
        }, { ciphertext: ciphertextChunk }, operator);
        logger === null || logger === void 0 ? void 0 : logger.debug({ startIdx, endIdx: startIdx + redactedPlaintext.length }, 'verified proof');
        realRedactedPlaintext.set(redactedPlaintext, startIdx);
    }));
    return {
        redactedPlaintext: realRedactedPlaintext,
    };
}
exports.verifyZKBlock = verifyZKBlock;
/**
 * Split the redacted plaintext into chacha-sized chunks,
 * and set a counter for each chunk.
 *
 * It will only return blocks that are fully or partially revealed
 * @param redactedPlaintext the redacted plaintext that need be split
 * @param blockSize the size of blocks to split data into
 */
function getBlockWithIvCounter(redactedPlaintext, blockSize = CHACHA_BLOCK_SIZE) {
    const chunks = chunkBuffer(redactedPlaintext, blockSize);
    const chunksWithCounter = [];
    for (let i = 0; i < chunks.length; i++) {
        if (!(0, redactions_1.isFullyRedacted)(chunks[i])) {
            chunksWithCounter.push({
                chunk: chunks[i],
                counter: i + 1,
            });
        }
    }
    return chunksWithCounter;
}
function chunkBuffer(buffer, chunkSize) {
    const chunks = [];
    for (let i = 0; i < buffer.length; i += chunkSize) {
        chunks.push(buffer.slice(i, i + chunkSize));
    }
    return chunks;
}
