"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseServerHello = void 0;
const crypto_1 = require("../crypto");
const constants_1 = require("./constants");
const generics_1 = require("./generics");
const packets_1 = require("./packets");
async function parseServerHello(data) {
    const serverVersion = read(2);
    const serverRandom = read(32);
    const sessionId = readWLength(1);
    const cipherSuiteBytes = read(2);
    const cipherSuite = constants_1.SUPPORTED_CIPHER_SUITES
        .find(k => (0, generics_1.areUint8ArraysEqual)(constants_1.SUPPORTED_CIPHER_SUITE_MAP[k].identifier, cipherSuiteBytes));
    if (!cipherSuite) {
        throw new Error(`Unsupported cipher suite '${cipherSuiteBytes}'`);
    }
    const compressionMethod = read(1)[0];
    if (compressionMethod !== 0x00) {
        throw new Error(`Unsupported compression method '${compressionMethod.toString(16)}'`);
    }
    const extensionsLength = (0, generics_1.uint8ArrayToDataView)(read(2)).getUint16(0);
    let publicKey;
    let publicKeyType;
    let supportsPsk = false;
    if (extensionsLength) {
        while (data.length) {
            const { type, extData } = readExtension();
            switch (type) {
                case 'SUPPORTED_VERSIONS':
                    if (!(0, generics_1.areUint8ArraysEqual)(constants_1.CURRENT_PROTOCOL_VERSION, extData)) {
                        throw new Error(`Server does not support TLS version. Version recv: '${extData}'`);
                    }
                    break;
                case 'KEY_SHARE':
                    const typeBytes = extData.slice(0, 2);
                    publicKeyType = constants_1.SUPPORTED_NAMED_CURVES
                        .find(k => (0, generics_1.areUint8ArraysEqual)(constants_1.SUPPORTED_NAMED_CURVE_MAP[k].identifier, typeBytes));
                    if (!publicKeyType) {
                        throw new Error(`Unsupported key type '${typeBytes}'`);
                    }
                    publicKey = (0, packets_1.expectReadWithLength)(extData.slice(2));
                    break;
                case 'PRE_SHARED_KEY':
                    supportsPsk = true;
                    break;
            }
        }
    }
    if (!publicKey || !publicKeyType) {
        throw new Error('Server did not send a public key');
    }
    return {
        serverVersion,
        serverRandom,
        sessionId,
        cipherSuite,
        publicKey: await crypto_1.crypto.importKey(constants_1.SUPPORTED_NAMED_CURVE_MAP[publicKeyType].algorithm, publicKey, 'public'),
        publicKeyType,
        supportsPsk
    };
    function read(bytes) {
        const result = data.slice(0, bytes);
        data = data.slice(bytes);
        return result;
    }
    function readWLength(bytesLength = 2) {
        const content = (0, packets_1.expectReadWithLength)(data, bytesLength);
        data = data.slice(content.length + bytesLength);
        return content;
    }
    function readExtension() {
        const typeByte = read(2)[1];
        const extData = readWLength(2);
        const type = constants_1.SUPPORTED_EXTENSIONS
            .find(k => constants_1.SUPPORTED_EXTENSION_MAP[k] === typeByte);
        return { type, extData };
    }
}
exports.parseServerHello = parseServerHello;
