"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseWrappedRecord = exports.encryptWrappedRecord = exports.decryptWrappedRecord = void 0;
const crypto_1 = require("../crypto");
const constants_1 = require("./constants");
const generics_1 = require("./generics");
async function decryptWrappedRecord(encryptedData, { authTag, key, iv, recordHeader, recordNumber, cipherSuite, }) {
    const { cipher } = constants_1.SUPPORTED_CIPHER_SUITE_MAP[cipherSuite];
    iv = recordNumber === undefined
        ? iv
        : (0, generics_1.generateIV)(iv, recordNumber);
    const { plaintext } = await crypto_1.crypto.authenticatedDecrypt(cipher, {
        key,
        iv,
        data: encryptedData,
        aead: recordHeader,
        authTag,
    });
    if (plaintext.length !== encryptedData.length) {
        throw new Error('Decrypted length does not match encrypted length');
    }
    return {
        plaintext: plaintext.slice(0, -1),
        contentType: plaintext[plaintext.length - 1],
    };
}
exports.decryptWrappedRecord = decryptWrappedRecord;
async function encryptWrappedRecord({ plaintext, contentType }, { key, iv, recordHeader, recordNumber, cipherSuite, }) {
    const { cipher } = constants_1.SUPPORTED_CIPHER_SUITE_MAP[cipherSuite];
    const completePlaintext = (0, generics_1.concatenateUint8Arrays)([
        plaintext,
        new Uint8Array([constants_1.CONTENT_TYPE_MAP[contentType]])
    ]);
    iv = recordNumber === undefined ? iv : (0, generics_1.generateIV)(iv, recordNumber);
    return crypto_1.crypto.authenticatedEncrypt(cipher, {
        key,
        iv,
        data: completePlaintext,
        aead: recordHeader,
    });
}
exports.encryptWrappedRecord = encryptWrappedRecord;
function parseWrappedRecord(data) {
    const encryptedData = data.slice(0, data.length - constants_1.AUTH_TAG_BYTE_LENGTH);
    const authTag = data.slice(data.length - constants_1.AUTH_TAG_BYTE_LENGTH);
    return { encryptedData, authTag };
}
exports.parseWrappedRecord = parseWrappedRecord;
