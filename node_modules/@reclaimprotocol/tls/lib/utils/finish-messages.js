"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.packFinishMessagePacket = exports.verifyFinishMessage = void 0;
const crypto_1 = require("../crypto");
const decryption_utils_1 = require("../utils/decryption-utils");
const constants_1 = require("./constants");
const generics_1 = require("./generics");
const packets_1 = require("./packets");
async function verifyFinishMessage(verifyData, opts) {
    const computedData = await computeFinishMessageHash(opts);
    if (!(0, generics_1.areUint8ArraysEqual)(computedData, verifyData)) {
        throw new Error('Invalid finish message');
    }
}
exports.verifyFinishMessage = verifyFinishMessage;
async function packFinishMessagePacket(opts) {
    const hash = await computeFinishMessageHash(opts);
    const packet = (0, generics_1.concatenateUint8Arrays)([
        new Uint8Array([constants_1.SUPPORTED_RECORD_TYPE_MAP.FINISHED, 0x00]),
        (0, packets_1.packWithLength)(hash)
    ]);
    return packet;
}
exports.packFinishMessagePacket = packFinishMessagePacket;
async function computeFinishMessageHash({ secret, handshakeMessages, cipherSuite }) {
    const { hashAlgorithm, hashLength } = constants_1.SUPPORTED_CIPHER_SUITE_MAP[cipherSuite];
    const handshakeHash = await (0, decryption_utils_1.getHash)(handshakeMessages, cipherSuite);
    const finishKey = await (0, decryption_utils_1.hkdfExtractAndExpandLabel)(hashAlgorithm, secret, 'finished', new Uint8Array(0), hashLength);
    const hmacKey = await crypto_1.crypto.importKey(hashAlgorithm, finishKey);
    return crypto_1.crypto.hmac(hashAlgorithm, hmacKey, handshakeHash);
}
