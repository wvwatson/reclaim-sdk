"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHash = exports.hkdfExtractAndExpandLabel = exports.deriveTrafficKeysForSide = exports.deriveTrafficKeys = exports.computeSharedKeys = exports.computeUpdatedTrafficMasterSecret = void 0;
const crypto_1 = require("../crypto");
const constants_1 = require("./constants");
const generics_1 = require("./generics");
const packets_1 = require("./packets");
function computeUpdatedTrafficMasterSecret(masterSecret, cipherSuite) {
    const { hashAlgorithm, hashLength } = constants_1.SUPPORTED_CIPHER_SUITE_MAP[cipherSuite];
    return hkdfExtractAndExpandLabel(hashAlgorithm, masterSecret, 'traffic upd', new Uint8Array(), hashLength);
}
exports.computeUpdatedTrafficMasterSecret = computeUpdatedTrafficMasterSecret;
async function computeSharedKeys({ hellos, masterSecret: masterKey, cipherSuite, secretType, earlySecret }) {
    const { hashAlgorithm, hashLength } = constants_1.SUPPORTED_CIPHER_SUITE_MAP[cipherSuite];
    const emptyHash = await crypto_1.crypto.hash(hashAlgorithm, new Uint8Array());
    const zeros = new Uint8Array(hashLength);
    let handshakeTrafficSecret;
    if (secretType === 'hs') {
        // some hashes
        earlySecret = earlySecret
            || await crypto_1.crypto.extract(hashAlgorithm, hashLength, zeros, '');
        const derivedSecret = await hkdfExtractAndExpandLabel(hashAlgorithm, earlySecret, 'derived', emptyHash, hashLength);
        handshakeTrafficSecret = await crypto_1.crypto.extract(hashAlgorithm, hashLength, masterKey, derivedSecret);
    }
    else {
        const derivedSecret = await hkdfExtractAndExpandLabel(hashAlgorithm, masterKey, 'derived', emptyHash, hashLength);
        handshakeTrafficSecret = await crypto_1.crypto.extract(hashAlgorithm, hashLength, zeros, derivedSecret);
    }
    return deriveTrafficKeys({
        hellos,
        cipherSuite,
        masterSecret: handshakeTrafficSecret,
        secretType
    });
}
exports.computeSharedKeys = computeSharedKeys;
async function deriveTrafficKeys({ masterSecret, cipherSuite, hellos, secretType, }) {
    const { hashAlgorithm, hashLength } = constants_1.SUPPORTED_CIPHER_SUITE_MAP[cipherSuite];
    const handshakeHash = await getHash(hellos, cipherSuite);
    const clientSecret = await hkdfExtractAndExpandLabel(hashAlgorithm, masterSecret, `c ${secretType} traffic`, handshakeHash, hashLength);
    const serverSecret = await hkdfExtractAndExpandLabel(hashAlgorithm, masterSecret, `s ${secretType} traffic`, handshakeHash, hashLength);
    const { encKey: clientEncKey, iv: clientIv } = await deriveTrafficKeysForSide(clientSecret, cipherSuite);
    const { encKey: serverEncKey, iv: serverIv } = await deriveTrafficKeysForSide(serverSecret, cipherSuite);
    return {
        masterSecret,
        clientSecret,
        serverSecret,
        clientEncKey,
        serverEncKey,
        clientIv,
        serverIv
    };
}
exports.deriveTrafficKeys = deriveTrafficKeys;
async function deriveTrafficKeysForSide(masterSecret, cipherSuite) {
    const { hashAlgorithm, keyLength, cipher } = constants_1.SUPPORTED_CIPHER_SUITE_MAP[cipherSuite];
    const ivLen = 12;
    const encKey = await hkdfExtractAndExpandLabel(hashAlgorithm, masterSecret, 'key', new Uint8Array(), keyLength);
    const iv = await hkdfExtractAndExpandLabel(hashAlgorithm, masterSecret, 'iv', new Uint8Array(0), ivLen);
    return {
        masterSecret,
        encKey: await crypto_1.crypto.importKey(cipher, encKey),
        iv
    };
}
exports.deriveTrafficKeysForSide = deriveTrafficKeysForSide;
async function hkdfExtractAndExpandLabel(algorithm, secret, label, context, length) {
    const tmpLabel = `tls13 ${label}`;
    const lengthBuffer = new Uint8Array(2);
    const lengthBufferView = (0, generics_1.uint8ArrayToDataView)(lengthBuffer);
    lengthBufferView.setUint16(0, length);
    const hkdfLabel = (0, generics_1.concatenateUint8Arrays)([
        lengthBuffer,
        (0, packets_1.packWithLength)((0, generics_1.strToUint8Array)(tmpLabel)).slice(1),
        (0, packets_1.packWithLength)(context).slice(1)
    ]);
    const key = await crypto_1.crypto.importKey(algorithm, secret);
    return crypto_1.crypto.expand(algorithm, length, key, length, hkdfLabel);
}
exports.hkdfExtractAndExpandLabel = hkdfExtractAndExpandLabel;
async function getHash(msgs, cipherSuite) {
    if (Array.isArray(msgs) && !(msgs instanceof Uint8Array)) {
        const { hashAlgorithm } = constants_1.SUPPORTED_CIPHER_SUITE_MAP[cipherSuite];
        return crypto_1.crypto.hash(hashAlgorithm, (0, generics_1.concatenateUint8Arrays)(msgs));
    }
    return msgs;
}
exports.getHash = getHash;
