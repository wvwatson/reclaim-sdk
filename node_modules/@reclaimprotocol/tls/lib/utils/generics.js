"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateIV = exports.strToUint8Array = exports.uint8ArrayToDataView = exports.areUint8ArraysEqual = exports.concatenateUint8Arrays = exports.xor = exports.toHexStringWithWhitespace = void 0;
/**
 * Converts a buffer to a hex string with whitespace between each byte
 * @returns eg. '01 02 03 04'
 */
function toHexStringWithWhitespace(buff, whitespace = ' ') {
    return [...buff]
        .map(x => x.toString(16).padStart(2, '0'))
        .join(whitespace);
}
exports.toHexStringWithWhitespace = toHexStringWithWhitespace;
function xor(a, b) {
    const result = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        result[i] = a[i] ^ b[i];
    }
    return result;
}
exports.xor = xor;
function concatenateUint8Arrays(arrays) {
    const totalLength = arrays.reduce((acc, curr) => acc + curr.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const arr of arrays) {
        result.set(arr, offset);
        offset += arr.length;
    }
    return result;
}
exports.concatenateUint8Arrays = concatenateUint8Arrays;
function areUint8ArraysEqual(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
exports.areUint8ArraysEqual = areUint8ArraysEqual;
function uint8ArrayToDataView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
exports.uint8ArrayToDataView = uint8ArrayToDataView;
function strToUint8Array(str) {
    return new TextEncoder().encode(str);
}
exports.strToUint8Array = strToUint8Array;
function generateIV(iv, recordNumber) {
    // make the recordNumber a buffer, so we can XOR with the main IV
    // to generate the specific IV to decrypt this packet
    const recordBuffer = new Uint8Array(iv.length);
    const recordBufferView = new DataView(recordBuffer.buffer);
    recordBufferView.setUint32(iv.length - 4, recordNumber);
    return xor(iv, recordBuffer);
}
exports.generateIV = generateIV;
