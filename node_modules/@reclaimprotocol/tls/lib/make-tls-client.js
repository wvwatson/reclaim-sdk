"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeTLSClient = void 0;
const client_hello_1 = require("./utils/client-hello");
const constants_1 = require("./utils/constants");
const decryption_utils_1 = require("./utils/decryption-utils");
const finish_messages_1 = require("./utils/finish-messages");
const generics_1 = require("./utils/generics");
const key_update_1 = require("./utils/key-update");
const logger_1 = require("./utils/logger");
const make_queue_1 = require("./utils/make-queue");
const packets_1 = require("./utils/packets");
const parse_alert_1 = require("./utils/parse-alert");
const parse_certificate_1 = require("./utils/parse-certificate");
const parse_server_hello_1 = require("./utils/parse-server-hello");
const session_ticket_1 = require("./utils/session-ticket");
const wrapped_record_1 = require("./utils/wrapped-record");
const crypto_1 = require("./crypto");
const RECORD_LENGTH_BYTES = 3;
function makeTLSClient({ host, verifyServerCertificate, rootCAs, logger: _logger, cipherSuites, namedCurves, write, onRecvData, onSessionTicket, onTlsEnd, onHandshake, onRecvCertificates }) {
    verifyServerCertificate = verifyServerCertificate !== false;
    namedCurves = namedCurves || constants_1.SUPPORTED_NAMED_CURVES;
    const logger = _logger || logger_1.logger;
    const processor = (0, packets_1.makeMessageProcessor)(logger);
    const { enqueue: enqueueServerPacket } = (0, make_queue_1.makeQueue)();
    const keyPairs = {};
    let handshakeDone = false;
    let ended = false;
    let sessionId = new Uint8Array();
    let handshakeMsgs = [];
    let cipherSuite = undefined;
    let earlySecret = undefined;
    let keys = undefined;
    let recordSendCount = 0;
    let recordRecvCount = 0;
    let keyType = undefined;
    let certificates = [];
    let handshakePacketStream = new Uint8Array();
    let clientCertificateRequested = false;
    const processPacket = (type, { header, content, authTag }) => {
        return enqueueServerPacket(async () => {
            if (ended) {
                logger.warn('connection closed, ignoring packet');
                return;
            }
            let data = content;
            let contentType;
            let ciphertext;
            switch (type) {
                case constants_1.PACKET_TYPE.HELLO:
                    break;
                case constants_1.PACKET_TYPE.WRAPPED_RECORD:
                    logger.trace('recv wrapped record');
                    const decrypted = await (0, wrapped_record_1.decryptWrappedRecord)(content, {
                        authTag,
                        key: keys.serverEncKey,
                        iv: keys.serverIv,
                        recordHeader: header,
                        recordNumber: recordRecvCount,
                        cipherSuite: cipherSuite,
                    });
                    data = decrypted.plaintext;
                    // exclude final byte (content type)
                    ciphertext = content.slice(0, -1);
                    contentType = decrypted.contentType;
                    logger.debug({
                        recordRecvCount,
                        contentType: contentType.toString(16),
                        length: data.length,
                    }, 'decrypted wrapped record');
                    recordRecvCount += 1;
                    break;
                case constants_1.PACKET_TYPE.CHANGE_CIPHER_SPEC:
                    // TLS 1.3 doesn't really have a change cipher spec
                    // this is just for compatibility with TLS 1.2
                    // so we do nothing here, and return
                    return;
                case constants_1.PACKET_TYPE.ALERT:
                    await handleAlert(content);
                    return;
                default:
                    logger.warn({
                        type: type.toString(16),
                        chunk: (0, generics_1.toHexStringWithWhitespace)(content)
                    }, 'cannot process message');
                    return;
            }
            try {
                await processRecord({
                    record: data,
                    contentType,
                    authTag,
                    ciphertext,
                });
            }
            catch (err) {
                logger.error({ err }, 'error processing record');
                end(err);
            }
        });
    };
    async function processRecord({ record, contentType, authTag, ciphertext }) {
        if (!contentType || contentType === constants_1.CONTENT_TYPE_MAP.HANDSHAKE) {
            handshakePacketStream = (0, generics_1.concatenateUint8Arrays)([handshakePacketStream, record]);
            let data = readPacket();
            while (data) {
                const { type, content } = data;
                switch (type) {
                    case constants_1.SUPPORTED_RECORD_TYPE_MAP.SERVER_HELLO:
                        logger.trace('received server hello');
                        const hello = await (0, parse_server_hello_1.parseServerHello)(content);
                        if (!hello.supportsPsk && earlySecret) {
                            throw new Error('Server does not support PSK');
                        }
                        cipherSuite = hello.cipherSuite;
                        keyType = hello.publicKeyType;
                        const { keyPair, algorithm } = await getKeyPair(keyType);
                        const masterSecret = await crypto_1.crypto.calculateSharedSecret(algorithm, keyPair.privKey, hello.publicKey);
                        keys = await (0, decryption_utils_1.computeSharedKeys)({
                            hellos: handshakeMsgs,
                            cipherSuite: hello.cipherSuite,
                            secretType: 'hs',
                            masterSecret,
                            earlySecret,
                        });
                        logger.debug({ cipherSuite, keyType }, 'processed server hello & computed shared keys');
                        break;
                    case constants_1.SUPPORTED_RECORD_TYPE_MAP.ENCRYPTED_EXTENSIONS:
                        logger.debug({ len: content.length }, 'received encrypted extensions');
                        break;
                    case constants_1.SUPPORTED_RECORD_TYPE_MAP.CERTIFICATE:
                        logger.debug({ len: content.length }, 'received certificate');
                        const result = (0, parse_certificate_1.parseCertificates)(content);
                        certificates = result.certificates;
                        onRecvCertificates === null || onRecvCertificates === void 0 ? void 0 : onRecvCertificates({ certificates });
                        break;
                    case constants_1.SUPPORTED_RECORD_TYPE_MAP.CERTIFICATE_VERIFY:
                        logger.debug({ len: content.length }, 'received certificate verify');
                        const signature = (0, parse_certificate_1.parseServerCertificateVerify)(content);
                        logger.debug({ alg: signature.algorithm }, 'parsed certificate verify');
                        if (!certificates.length) {
                            throw new Error('No certificates received');
                        }
                        await (0, parse_certificate_1.verifyCertificateSignature)({
                            ...signature,
                            publicKey: certificates[0].getPublicKey(),
                            hellos: handshakeMsgs.slice(0, -1),
                            cipherSuite: cipherSuite
                        });
                        if (verifyServerCertificate) {
                            await (0, parse_certificate_1.verifyCertificateChain)(certificates, host, rootCAs);
                        }
                        break;
                    case constants_1.SUPPORTED_RECORD_TYPE_MAP.FINISHED:
                        await processServerFinish(content);
                        break;
                    case constants_1.SUPPORTED_RECORD_TYPE_MAP.KEY_UPDATE:
                        const newMasterSecret = await (0, decryption_utils_1.computeUpdatedTrafficMasterSecret)(keys.serverSecret, cipherSuite);
                        const newKeys = await (0, decryption_utils_1.deriveTrafficKeysForSide)(newMasterSecret, cipherSuite);
                        keys = {
                            ...keys,
                            serverSecret: newMasterSecret,
                            serverEncKey: newKeys.encKey,
                            serverIv: newKeys.iv,
                        };
                        recordRecvCount = 0;
                        logger.debug('updated server traffic keys');
                        break;
                    case constants_1.SUPPORTED_RECORD_TYPE_MAP.SESSION_TICKET:
                        logger.debug({ len: record.length }, 'received session ticket');
                        const ticket = (0, session_ticket_1.parseSessionTicket)(content);
                        onSessionTicket === null || onSessionTicket === void 0 ? void 0 : onSessionTicket(ticket);
                        break;
                    case constants_1.SUPPORTED_RECORD_TYPE_MAP.CERTIFICATE_REQUEST:
                        logger.debug('received client certificate request');
                        clientCertificateRequested = true;
                        break;
                    default:
                        logger.warn({ type: type.toString(16) }, 'cannot process record');
                        break;
                }
                data = readPacket();
            }
            function readPacket() {
                if (!handshakePacketStream.length) {
                    return;
                }
                const type = handshakePacketStream[0];
                const content = (0, packets_1.readWithLength)(handshakePacketStream.slice(1), RECORD_LENGTH_BYTES);
                if (!content) {
                    logger.warn('missing bytes from packet');
                    return;
                }
                const totalLength = 1 + RECORD_LENGTH_BYTES + content.length;
                if (!handshakeDone) {
                    handshakeMsgs.push(handshakePacketStream.slice(0, totalLength));
                }
                handshakePacketStream = handshakePacketStream.slice(totalLength);
                return { type, content };
            }
        }
        else if (contentType === constants_1.CONTENT_TYPE_MAP.APPLICATION_DATA) {
            logger.trace({ len: record.length }, 'received application data');
            onRecvData === null || onRecvData === void 0 ? void 0 : onRecvData(record, { authTag: authTag, ciphertext: ciphertext, });
        }
        else if (contentType === constants_1.CONTENT_TYPE_MAP.ALERT) {
            await handleAlert(record);
        }
        else {
            logger.warn({ record: record, contentType: contentType.toString(16) }, 'cannot process record');
        }
    }
    async function handleAlert(content) {
        const { level, description } = (0, parse_alert_1.parseTlsAlert)(content);
        const msg = (description === 'HANDSHAKE_FAILURE' || description === 'PROTOCOL_VERSION'
            ? 'Unsupported TLS version. Only TLS 1.3 websites with EC certificates are supported'
            : 'received alert');
        logger[level === 'WARNING' ? 'warn' : 'error']({ level, description }, msg);
        if (level === 'FATAL'
            || description === 'CLOSE_NOTIFY') {
            end(level === 'FATAL'
                ? new Error(`Fatal alert: ${description}`)
                : undefined);
        }
    }
    async function sendClientCertificate() {
        if (clientCertificateRequested) {
            const clientZeroCert = (0, generics_1.concatenateUint8Arrays)([
                new Uint8Array([constants_1.SUPPORTED_RECORD_TYPE_MAP.CERTIFICATE, 0x00]),
                (0, packets_1.packWithLength)(new Uint8Array([0, 0, 0, 0]))
            ]);
            logger.trace({ cert: (0, generics_1.toHexStringWithWhitespace)(clientZeroCert) }, 'sending zero certs');
            await writeEncryptedPacket({
                type: 'WRAPPED_RECORD',
                data: clientZeroCert,
                contentType: 'HANDSHAKE'
            });
            handshakeMsgs.push(clientZeroCert);
        }
    }
    async function processServerFinish(serverFinish) {
        logger.debug('received server finish');
        //derive server keys now to streamline handshake messages handling
        const serverKeys = await (0, decryption_utils_1.computeSharedKeys)({
            // we only use handshake messages till the server finish
            hellos: handshakeMsgs,
            cipherSuite: cipherSuite,
            secretType: 'ap',
            masterSecret: keys.masterSecret,
        });
        // the server hash computation does not include
        // the server finish, so we need to exclude it
        const handshakeMsgsForServerHash = handshakeMsgs.slice(0, -1);
        (0, finish_messages_1.verifyFinishMessage)(serverFinish, {
            secret: keys.serverSecret,
            handshakeMessages: handshakeMsgsForServerHash,
            cipherSuite: cipherSuite
        });
        logger.debug('server finish verified');
        // this might add an extra message to handshakeMsgs and affect handshakeHash
        await sendClientCertificate();
        const clientFinish = await (0, finish_messages_1.packFinishMessagePacket)({
            secret: keys.clientSecret,
            handshakeMessages: handshakeMsgs,
            cipherSuite: cipherSuite
        });
        logger.trace({ finish: (0, generics_1.toHexStringWithWhitespace)(clientFinish) }, 'sending client finish');
        await writeEncryptedPacket({
            type: 'WRAPPED_RECORD',
            data: clientFinish,
            contentType: 'HANDSHAKE'
        });
        // add the client finish to the handshake messages
        handshakeMsgs.push(clientFinish);
        // switch to using the provider keys
        keys = serverKeys;
        // also the send/recv counters are reset
        // once we switch to the provider keys
        recordSendCount = 0;
        recordRecvCount = 0;
        handshakeDone = true;
        onHandshake === null || onHandshake === void 0 ? void 0 : onHandshake();
    }
    async function writeEncryptedPacket(opts) {
        logger.trace({ ...opts, data: (0, generics_1.toHexStringWithWhitespace)(opts.data) }, 'writing enc packet');
        // total length = data len + 1 byte for record type + auth tag len
        const dataLen = opts.data.length + 1 + constants_1.AUTH_TAG_BYTE_LENGTH;
        const header = (0, packets_1.packPacketHeader)(dataLen, opts);
        const { ciphertext, authTag } = await (0, wrapped_record_1.encryptWrappedRecord)({ plaintext: opts.data, contentType: opts.contentType }, {
            key: keys.clientEncKey,
            iv: keys.clientIv,
            recordHeader: header,
            recordNumber: recordSendCount,
            cipherSuite: cipherSuite,
        });
        recordSendCount += 1;
        await write({ header, content: ciphertext, authTag });
    }
    async function writePacket(opts) {
        logger.trace({ ...opts, data: (0, generics_1.toHexStringWithWhitespace)(opts.data) }, 'writing packet');
        const header = (0, packets_1.packPacketHeader)(opts.data.length, opts);
        await write({ header, content: opts.data });
    }
    async function end(error) {
        await enqueueServerPacket(() => { });
        handshakeDone = false;
        handshakeMsgs = [];
        keys = undefined;
        recordSendCount = 0;
        recordRecvCount = 0;
        earlySecret = undefined;
        processor.reset();
        ended = true;
        onTlsEnd === null || onTlsEnd === void 0 ? void 0 : onTlsEnd(error);
    }
    async function getKeyPair(keyType) {
        const algorithm = constants_1.SUPPORTED_NAMED_CURVE_MAP[keyType].algorithm;
        if (!keyPairs[keyType]) {
            keyPairs[keyType] = await crypto_1.crypto.generateKeyPair(algorithm);
        }
        return {
            algorithm,
            keyPair: keyPairs[keyType]
        };
    }
    return {
        getMetadata() {
            return {
                cipherSuite,
                keyType,
            };
        },
        hasEnded() {
            return ended;
        },
        getKeyPair() {
            if (!keyType) {
                throw new Error('handshake not done yet');
            }
            return keyPairs[keyType];
        },
        /**
         * Get the current traffic keys
         */
        getKeys() {
            if (!keys) {
                return undefined;
            }
            return { ...keys, recordSendCount, recordRecvCount };
        },
        /**
         * Session ID used to connect to the server
         */
        getSessionId() {
            return sessionId;
        },
        isHandshakeDone() {
            return handshakeDone;
        },
        getPskFromTicket(ticket) {
            return (0, session_ticket_1.getPskFromTicket)(ticket, {
                masterKey: keys.masterSecret,
                hellos: handshakeMsgs,
                cipherSuite: cipherSuite,
            });
        },
        /**
         * Start the handshake with the server
         */
        async startHandshake(opts) {
            if (handshakeDone) {
                throw new Error('Handshake already done');
            }
            sessionId = crypto_1.crypto.randomBytes(32);
            ended = false;
            const clientHello = await (0, client_hello_1.packClientHello)({
                host,
                keysToShare: await Promise.all(namedCurves
                    .map(async (keyType) => {
                    const { keyPair } = await getKeyPair(keyType);
                    return {
                        type: keyType,
                        key: keyPair.pubKey,
                    };
                })),
                random: (opts === null || opts === void 0 ? void 0 : opts.random) || crypto_1.crypto.randomBytes(32),
                sessionId,
                psk: opts === null || opts === void 0 ? void 0 : opts.psk,
                cipherSuites
            });
            handshakeMsgs.push(clientHello);
            if (opts === null || opts === void 0 ? void 0 : opts.psk) {
                earlySecret = opts.psk.earlySecret;
            }
            await writePacket({
                type: 'HELLO',
                data: clientHello,
            });
        },
        /**
         * Handle bytes received from the server.
         * Could be a complete or partial TLS packet
         */
        handleReceivedBytes(data) {
            processor.onData(data, processPacket);
        },
        /**
         * Handle a complete TLS packet received
         * from the server
         */
        handleReceivedPacket: processPacket,
        /**
         * Utilise the KeyUpdate handshake message to update
         * the traffic keys. Available only in TLS 1.3
         * @param requestUpdateFromServer should the server be requested to
         * update its keys as well
         */
        async updateTrafficKeys(requestUpdateFromServer = false) {
            const packet = (0, key_update_1.packKeyUpdateRecord)(requestUpdateFromServer
                ? 'UPDATE_REQUESTED'
                : 'UPDATE_NOT_REQUESTED');
            await writeEncryptedPacket({
                data: packet,
                type: 'WRAPPED_RECORD',
                contentType: 'HANDSHAKE'
            });
            const newMasterSecret = await (0, decryption_utils_1.computeUpdatedTrafficMasterSecret)(keys.clientSecret, cipherSuite);
            const newKeys = await (0, decryption_utils_1.deriveTrafficKeysForSide)(newMasterSecret, cipherSuite);
            keys = {
                ...keys,
                clientSecret: newMasterSecret,
                clientEncKey: newKeys.encKey,
                clientIv: newKeys.iv,
            };
            recordSendCount = 0;
            logger.info('updated client traffic keys');
        },
        write(data) {
            if (!handshakeDone) {
                throw new Error('Handshake not done');
            }
            return writeEncryptedPacket({
                type: 'WRAPPED_RECORD',
                data,
                contentType: 'APPLICATION_DATA'
            });
        },
        end,
    };
}
exports.makeTLSClient = makeTLSClient;
